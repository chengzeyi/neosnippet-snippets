include c.snip

snippet     returnn
alias       retn
abbr        return nullptr;
    return nullptr;

# #include <...>
snippet     inc
options     head
alias       include #inc #include
abbr        #include <...>
    #include <${1:iostream}>${0}

# #include "..."
snippet     incq
options     head
alias       includeq include_quote #incq #includeq #include_quote
abbr        #include "..."
    #include "${1}"${0}

snippet     template
abbr        template <T>
    template<typename ${1:T}>${0}

snippet     struct_full
alias       structf
options     head
abbr        struct {...}
    struct ${1:#:NAME} {
        $1(${3});
        ${2}
    };

    $1::$1($3) {
        ${0:TARGET}
    }

snippet     class_full
alias       classf
options     head
abbr        class {...}
    class ${1:#:NAME} {
    public:
        $1(${3});
        ${2}
    };

    $1::$1($3) {
        ${0:TARGET}
    }

snippet     class
options     head
abbr        class {}
    class ${1:#:NAME} {
        ${0:TARGET}
    };

snippet     delete_copy
alias       deletec
options     head
abbr        (const &) = delete; operator=(const &) = delete;
    ${1:#:NAME}(const $1 &) = delete;
    $1 &operator=(const $1 &) = delete;

snippet     delete_move
alias       deletem
options     head
abbr        (const &) = delete; operator=(const &) = delete;
    ${1:#:NAME}($1 &&) = delete;
    $1 &operator=($1 &&) = delete;

snippet     function_member
options     head
alias       funcm
abbr        type class::func() {}
    ${1:void} ${2:#:CLASS_NAME}::${3:#:FUNC_NAME}(${4:void}) {
        ${0:TARGET}
    }

snippet     function_member_declare
options     head
alias       funcmd
abbr        type func();
    ${1:void} ${2:#:FUNC_NAME}(${3:void});

snippet     virtual
options     head
abbr        virtual type class::func() {}
    virtual ${1:void} ${2:#:CLASS_NAME}::${3:#:FUNC_NAME}(${4:void}) {
        ${0:TARGET}
    }

snippet     virtual_declare
options     head
alias       virtuald
abbr        virtual type class::func() {}
    virtual ${1:void} ${2:#:FUNC_NAME}(${3:void});

snippet     virtual_pure
options     head
alias       virtualp
abbr        virtual type class::func() {}
    virtual ${1:void} ${2:#:FUNC_NAME}(${3:void}) = 0;

snippet     try
options     head
abbr        try {}
    try {
        ${0:TARGET}
    }

snippet     try_catch
alias       tryc
options     head
abbr        try {} catch () {}
    try {
        ${1:TARGET}
    } catch (${2:...}) {
        ${3}
    }

snippet     catch
abbr        catch {}
    catch (${1:...}) {
        ${0:TARGET}
    }

# range based for ( C++11 feature )
snippet     forr
options     head
abbr        for (... : ...) {}
    for (${1:auto &&}${2:var} : ${3:#:CONTAINER}) {
        ${0:TARGET}
    }

snippet     for_each
options     head
alias       fore
abbr        std::for_each();
    std::for_each(${1:#:CONTAINER}.begin(), $1.end(), ${2:#:FUNC});

snippet     forit
options     head
abbr        for (it = begin(); it != end(); ++it)
    for (${1:auto &&}${2:it} = ${3:#:CONTAINER}.begin(); $2 != $3.end(); ++$2) {
        ${0:TARGET}
    }

# lambda expression ( C++11 feature )
snippet     lambda
abbr        [](){}
    [${1}](${2})${3: -> ${4:void\}} { ${5:TARGET} }${0}

snippet     lambda_multi
alias       lambdam
abbr        [](){}
    [${1}](${2})${3: -> ${4:void\}} {
        ${5:TARGET}
    }${0}

# scoped enumeration ( C++11 feature )
snippet     enum_scoped
options     head
alias       enums
abbr        enum struct {};
    enum struct ${1:#:NAME} { ${2:TARGET} };

# static assert ( C++11 feature )
snippet     static_assert
abbr        static_assert(,"");
    static_assert(${1:TARGET}, "${2}");

snippet     namespace
options     head
abbr        namespace {}
	namespace ${1:#:NAME} {
	${0:TARGET}
	} // namespace $1

snippet     static_cast
abbr        static_cast<>()
    static_cast<${1}>(${2:TARGET})${0}

snippet     reinterpret_cast
abbr        reinterpret_cast<>()
    reinterpret_cast<${1}>(${2:TARGET})${0}

snippet     const_cast
abbr        const_cast<>()
    const_cast<${1}>(${2:TARGET})${0}

snippet     dynamic_cast
abbr        dynamic_cast<>()
    dynamic_cast<${1}>(${2:TARGET})${0}

snippet     decltype
abbr        decltype()
    decltype(${1:TARGET})${0}

snippet     helloworld
options     head
abbr        #include<iostream> int main...
    #include <iostream>

    int main(int argc, char *argv[]) {
        std::cout << "Hello, world!" << std::endl;
        return 0;
    }

snippet     cin
options     head
abbr        std::cin >> ...;
    std::cin >> ${0:TARGET};

snippet     cout
options     head
abbr        std::cout << ... << std::endl;
    std::cout << ${0:TARGET} << std::endl;

snippet     cerr
options     head
abbr        std::cerr << ... << std::endl;
    std::cerr << ${0:TARGET} << std::endl;

snippet     debug
options     head
abbr        std::cerr << __FILE__ << ":" << __LINE__ << std::endl;
    std::cerr << __FILE__ << ":" << __LINE__ << ":" << ${1:"@DEBUG@"} << std::endl;

snippet     ignore
options     head
abbr        std::cin.ignore(...);
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

snippet     now
options     head
abbr        t = std::chrono::high_resolution_clock::now();
    auto &&${1:TARGET:t} = std::chrono::high_resolution_clock::now();

snippet     duration
abbr        std::chrono::duration<double>(...).count()
    std::chrono::duration<double>(${1:TARGET:t2 - t1})

snippet     time_span
alias       times
options     head
abbr        { t1; ... t2; span; }
    auto &&${1:t1} = std::chrono::high_resolution_clock::now();
    ${0:TARGET}
    auto &&${2:t2} = std::chrono::high_resolution_clock::now();
    auto &&${3:span} = std::chrono::duration<double>($2 - $1);

snippet     duration
abbr        std::chrono::duration<double>(...).count()
    std::chrono::duration<double>(${1:TARGET:t_end - t_start}).count()

snippet     stdarray
abbr        std::array<T, N>
    std::array<${1:T}, ${2:N}>${0}

snippet     stdvector
abbr        std::vector<T>
    std::vector<${1:T}>${0}

snippet     stddeque
abbr        std::deque<T>
    std::deque<${1:T}>${0}

snippet     stdqueue
abbr        std::queue<T>
    std::queue<${1:T}>${0}

snippet     stdpriority_queue
abbr        std::priority_queue<T>
    std::priority_queue<${1:T}>${0}

snippet     stdstack
abbr        std::stack<T>
    std::stack<${1:T}>${0}

snippet     stdforward_list
abbr        std::forward_list<T>
    std::forward_list<${1:T}>${0}

snippet     stdlist
abbr        std::list<T>
    std::list<${1:T}>${0}

snippet     stdset
abbr        std::set<T>
    std::set<${1:T}>${0}

snippet     stdmultiset
abbr        std::multiset<T>
    std::multiset<${1:T}>${0}

snippet     stdunordered_set
abbr        std::unordered_set<T>
    std::unordered_set<${1:T}>${0}

snippet     stdunordered_multiset
abbr        std::unordered_multiset<T>
    std::unordered_multiset<${1:T}>${0}

snippet     stdmap
abbr        std::map<K, V>
    std::map<${1:K}, ${2:V}>${0}

snippet     stdmultimap
abbr        std::multimap<K, V>
    std::multimap<${1:K}, ${2:V}>${0}

snippet     stdunordered_map
abbr        std::unordered_map<K, V>
    std::unordered_map<${1:K}, ${2:V}>${0}

snippet     stdunordered_multimap
abbr        std::unordered_multimap<K, V>
    std::unordered_multimap<${1:K}, ${2:V}>${0}

snippet     stdpair
abbr        std::pair<F, S>
    std::pair<${1:F}, ${2:S}>${0}

snippet    stdshared_ptr
abbr       std::shared_ptr<T>
    std::shared_ptr<${1:T}>${0}

snippet    stdunique_ptr
abbr       std::unique_ptr<T>
    std::unique_ptr<${1:T}>${0}
